import React from "react";
import { QueryObserverResult, UseQueryOptions } from "@tanstack/react-query";
import { BaseRecord, CrudFilters, CrudSorting, GetListResponse, SuccessErrorNotification, HttpError, MetaDataQuery, LiveModeProps } from "../../interfaces";
declare type SetFilterBehavior = "merge" | "replace";
export declare type useTableProps<TData, TError> = {
    /**
     * Resource name for API data interactions
     * @default Resource name that it reads from route
     */
    resource?: string;
    /**
     * Initial page index
     * @default 1
     */
    initialCurrent?: number;
    /**
     * Initial number of items per page
     * @default 10
     */
    initialPageSize?: number;
    /**
     * Initial sorter state
     */
    initialSorter?: CrudSorting;
    /**
     * Default and unchangeable sorter state
     *  @default `[]`
     */
    permanentSorter?: CrudSorting;
    /**
     * Initial filter state
     */
    initialFilter?: CrudFilters;
    /**
     * WDefault and unchangeable filter state
     * @default `[]`
     */
    permanentFilter?: CrudFilters;
    /**
     *Default behavior of the `setFilters` function
     * @default `"merge"`
     */
    defaultSetFilterBehavior?: SetFilterBehavior;
    /**
     * Whether to use server side pagination or not.
     * @default `true`
     */
    hasPagination?: boolean;
    /**
     * Sortings, filters, page index and records shown per page are tracked by browser history
     * @default Value set in [Refine](/docs/api-reference/core/components/refine-config/#syncwithlocation). If a custom resource is given, it will be `false`
     */
    syncWithLocation?: boolean;
    /**
     * react-query's [useQuery](https://tanstack.com/query/v4/docs/reference/useQuery) options
     */
    queryOptions?: UseQueryOptions<GetListResponse<TData>, TError>;
    /**
     * Metadata query for dataProvider
     */
    metaData?: MetaDataQuery;
    /**
     * If there is more than one `dataProvider`, you should use the `dataProviderName` that you will use.
     */
    dataProviderName?: string;
} & SuccessErrorNotification & LiveModeProps;
declare type ReactSetState<T> = React.Dispatch<React.SetStateAction<T>>;
declare type SyncWithLocationParams = {
    pagination: {
        current?: number;
        pageSize?: number;
    };
    sorter: CrudSorting;
    filters: CrudFilters;
};
export declare type useTablePaginationKeys = "current" | "setCurrent" | "pageSize" | "setPageSize" | "pageCount";
export declare type useTableReturnType<TData extends BaseRecord = BaseRecord, TError extends HttpError = HttpError> = {
    tableQueryResult: QueryObserverResult<GetListResponse<TData>, TError>;
    sorter: CrudSorting;
    setSorter: (sorter: CrudSorting) => void;
    filters: CrudFilters;
    setFilters: ((filters: CrudFilters, behavior?: SetFilterBehavior) => void) & ((setter: (prevFilters: CrudFilters) => CrudFilters) => void);
    createLinkForSyncWithLocation: (params: SyncWithLocationParams) => string;
    current: number;
    setCurrent: ReactSetState<useTableReturnType["current"]>;
    pageSize: number;
    setPageSize: ReactSetState<useTableReturnType["pageSize"]>;
    pageCount: number;
};
export declare type useTableNoPaginationReturnType<TData extends BaseRecord = BaseRecord, TError extends HttpError = HttpError> = Omit<useTableReturnType<TData, TError>, useTablePaginationKeys> & Record<useTablePaginationKeys, undefined>;
export declare function useTable<TData extends BaseRecord = BaseRecord, TError extends HttpError = HttpError>(props?: useTableProps<TData, TError> & {
    hasPagination?: true;
}): useTableReturnType<TData, TError>;
export declare function useTable<TData extends BaseRecord = BaseRecord, TError extends HttpError = HttpError>(props?: useTableProps<TData, TError> & {
    hasPagination: false;
}): useTableNoPaginationReturnType<TData, TError>;
export {};
//# sourceMappingURL=index.d.ts.map