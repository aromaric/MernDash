import{stringify as Y}from"query-string";import{stringify as u}from"query-string";var w=t=>{switch(t){case"ne":case"gte":case"lte":return`_${t}`;case"contains":return"_like";case"eq":default:return""}};var g=t=>{if(t&&t.length>0){let a=[],r=[];return t.map(e=>{a.push(e.field),r.push(e.order)}),{_sort:a,_order:r}}};var $=t=>{let a={};return t&&t.map(r=>{if(r.operator==="or"||r.operator==="and")throw new Error(`[@pankod/refine-simple-rest]: \`operator: ${r.operator}\` is not supported. You can create custom data provider. https://refine.dev/docs/api-reference/core/providers/data-provider/#creating-a-data-provider`);if("field"in r){let{field:e,operator:o,value:s}=r;if(e==="q"){a[e]=s;return}let n=w(o);a[`${e}${n}`]=s}}),a};import F from"axios";var x=F.create();x.interceptors.response.use(t=>t,t=>{var r,e,o;let a={...t,message:(e=(r=t.response)==null?void 0:r.data)==null?void 0:e.message,statusCode:(o=t.response)==null?void 0:o.status};return Promise.reject(a)});var v=(t,a=x)=>({getList:async({resource:r,hasPagination:e=!0,pagination:o={current:1,pageSize:10},filters:s,sort:n})=>{let f=`${t}/${r}`,{current:p=1,pageSize:c=10}=o!=null?o:{},d=$(s),m=e?{_start:(p-1)*c,_end:p*c}:{},i=g(n);if(i){let{_sort:O,_order:S}=i;m._sort=O.join(","),m._order=S.join(",")}let{data:_,headers:y}=await a.get(`${f}?${u(m)}&${u(d)}`),l=+y["x-total-count"];return{data:_,total:l}},getMany:async({resource:r,ids:e})=>{let{data:o}=await a.get(`${t}/${r}?${u({id:e})}`);return{data:o}},create:async({resource:r,variables:e})=>{let o=`${t}/${r}`,{data:s}=await a.post(o,e);return{data:s}},update:async({resource:r,id:e,variables:o})=>{let s=`${t}/${r}/${e}`,{data:n}=await a.patch(s,o);return{data:n}},getOne:async({resource:r,id:e})=>{let o=`${t}/${r}/${e}`,{data:s}=await a.get(o);return{data:s}},deleteOne:async({resource:r,id:e,variables:o})=>{let s=`${t}/${r}/${e}`,{data:n}=await a.delete(s,{data:o});return{data:n}},getApiUrl:()=>t,custom:async({url:r,method:e,filters:o,sort:s,payload:n,query:f,headers:p})=>{let c=`${r}?`;if(s){let i=g(s);if(i){let{_sort:_,_order:y}=i,l={_sort:_.join(","),_order:y.join(",")};c=`${c}&${u(l)}`}}if(o){let i=$(o);c=`${c}&${u(i)}`}f&&(c=`${c}&${u(f)}`),p&&(a.defaults.headers={...a.defaults.headers,...p});let d;switch(e){case"put":case"post":case"patch":d=await a[e](r,n);break;case"delete":d=await a.delete(r,{data:n});break;default:d=await a.get(c);break}let{data:m}=d;return Promise.resolve({data:m})}});var B=v;export{x as axiosInstance,B as default,$ as generateFilter,g as generateSort,w as mapOperator,Y as stringify};
//# sourceMappingURL=index.js.map